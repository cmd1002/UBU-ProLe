options {
    STATIC=false;
}

PARSER_BEGIN(Compiler)

import java.util.Stack;

public class Compiler {
    public static void main(String args[]) throws java.io.FileNotFoundException {
        final Compiler compiler = initCompiler(args);
        final Stack<String> stack = new Stack<String>();

        try {
            compiler.program();
        } catch (ParseException ex) {
            System.out.println("Parser caught an unexpected exception, exiting...");
            return;
        }
    }

    static Compiler initCompiler(String args[]) throws java.io.FileNotFoundException {
        if (args.length < 1) {
            return new Compiler(System.in);
        }
        return new Compiler(new java.io.FileInputStream(args[0]));
    }
}
PARSER_END(Compiler)

TOKEN_MGR_DECLS : {}

TOKEN : {
    <"\n">
|   <#NUMBER: (["0"-"9"])+>
|   <#ALPHA: ["a"-"z", "A"-"Z"]>
|   <#VARIABLE: (<ALPHA> | "_") (<ALPHA> | <NUMBER> | "_")*>
|   <#ASSIGMENT: "=" | "+=" | "-=" | "/=" | "*=">
|   <END: "end">
|   <THEN: "then">
|   <DO: "do">
|   <ELSE: "else">
|   <IF: "if">
|   <ELIF: "elsif">
|   <UNLESS: "unless">
|   <UNTIL: "until">
|   <WHILE: "while">
|   <PRINT: "print">
|   <EOL: ";">
|   <ADDITION: "+">
|   <SUBSTRACTION: "-">
|   <MULTIPLICATION: "*">
|   <DIVISION: "/">
|   <PARENTHESIS_START: "(">
|   <PARENTHESIS_END: ")">
|   <RESERVED: "class" | "ensure" | "nil" | "self" | "while" | "alias" | "defined" | "for" | "or" | "then" | "elsif" | "do" | "else" | "begin" | "unless" | "until" | "end" | "return" | "next" | "if" | "print">
}
SKIP : {
    <~[]>
    | <COM_LINE: "#"(~["\n"])*"\n">
    | <COM_MULTI_START: "=begin" > : COM_MULTI
}

<COM_MULTI>TOKEN : { // MULTI-LINE COMMENT
    <COM_MULTI_END: "=end"> : DEFAULT
    | <COM_MULTI_OTHER: ~[]>
    | <COM_MULTI_LONGEST: (~["="])+>
}

void program() : {} {
    statement() (program2())?
}

void program2(): {} {
    ";" program()
}

void statement() : { } {
    primmary()
    | <VARIABLE_STATEMENT: <VARIABLE>> assigment() expression()
}

void assigment() : {} {
    <ASSIGMENT_ASSIGMENT: <ASSIGMENT>>
}

void primmary() : {} {
    primmaryIf() (primmaryElseIf())* (primmaryElse())? <END>
|   primmaryUnless() (primmaryElse())? <END>
|   primmaryUntil() <END>
|   primmaryWhile() <END>
|   primmaryPrint()
}

void primmaryThen() : {} {
    <THEN> program()
}

void primmaryDo() : {
    <DO> program()
}

void primmaryElse() : {} {
    <ELSE> program()
}

void primmaryIf() : {} {
    <IF> expression() primmaryThen()
}

void primmaryElseIf() : {} {
    <ELIF> expression() primmaryThen()
}

void primmaryUnless() : {} {
    <UNLESS> expression() primmaryThen()
}

void primmaryUntil() : {} {
    <UNTIL> expression() primmaryDo()
}

void primmaryWhile() : {} {
    <WHILE> expression() primmaryDo()
}

void primmaryPrint() : {} {
    <PRINT> expression()
}

void expression() : {} {
    mexpression() (expression2())?
}

void expression2() : {} {
    (<ADDITION> | <SUBSTRACTION>) mexpression() expression2()
}

void mexpression() : {} {
    value() mexpression2()
}

void mexpression2() : {} {
    (<MULTIPLICATION> | <DIVISION>) value() mexpression2()
}

void value() : {} {
    <VALUE_NUMBER: <NUMBER>>
|   <VALUE_VARIABLE: <VARIABLE>>
|   <PARENTHESIS_START> expression() <PARENTHESIS_END>
}